---
phase: 01-aesthetic-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - components/FloatingParticles.tsx
  - components/GradientOrb.tsx
autonomous: true
requirements:
  - AES-05

must_haves:
  truths:
    - "Scrolling FloatingParticles completely off-screen causes particles to stop animating (no CPU wasted)"
    - "Scrolling GradientOrb completely off-screen causes the pulse animation to stop"
    - "Scrolling them back into view restores the animations seamlessly"
    - "No hydration errors — Math.random() remains in useEffect, not in render body"
  artifacts:
    - path: "components/FloatingParticles.tsx"
      provides: "Particle animation with off-screen pause"
      contains: "useInView"
    - path: "components/GradientOrb.tsx"
      provides: "Orb animation with off-screen pause"
      contains: "useInView"
  key_links:
    - from: "components/FloatingParticles.tsx"
      to: "isInView boolean"
      via: "useInView(containerRef) gates animate prop"
      pattern: "animate=\\{isInView"
    - from: "components/GradientOrb.tsx"
      to: "isInView boolean"
      via: "useInView(ref) gates animate prop"
      pattern: "animate=\\{isInView"
---

<objective>
Add useInView gates to FloatingParticles and GradientOrb so their looping animations pause when scrolled off-screen.

Purpose: FloatingParticles runs 20 concurrent looping animations. GradientOrb runs a continuous scale+opacity loop. Both waste CPU when not visible. Off-screen pause eliminates this with zero UX impact — users can't see off-screen content anyway. This also complies with reduced-motion expectations for performance-sensitive users.
Output: Updated FloatingParticles.tsx and GradientOrb.tsx with useInView-gated animations.
</objective>

<execution_context>
@/Users/Farhan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Farhan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-aesthetic-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add useInView pause to FloatingParticles.tsx</name>
  <files>components/FloatingParticles.tsx</files>
  <action>
    The current FloatingParticles.tsx correctly generates random values inside `useEffect` (NOT in render body — this prevents hydration errors). This pattern MUST be preserved. Only ADD the useInView gate on top of the existing structure.

    Changes required:
    1. Add `useRef` to the existing React import (already imports `useState`, `useEffect`)
    2. Add `useInView` to the framer-motion import (alongside existing `motion`)
    3. Create `containerRef` with `useRef<HTMLDivElement>(null)`
    4. Call `const isInView = useInView(containerRef)` — this returns `true` when the element intersects viewport
    5. Attach `ref={containerRef}` to the outer `<div className="absolute inset-0 overflow-hidden pointer-events-none">`
    6. Change each particle's `animate` prop from the current static object to a conditional:
       - When `isInView === true`: `animate={{ y: [0, -100, 0], opacity: [0, 1, 0] }}`
       - When `isInView === false`: `animate={false}` — framer-motion stops and resets to initial values
    7. Make `transition` also conditional:
       - When `isInView`: `transition={{ duration: particle.duration, repeat: Infinity, delay: particle.delay, ease: "easeInOut" }}`
       - When not `isInView`: `transition={{ duration: 0 }}`

    CRITICAL: Do NOT call Math.random() anywhere outside the useEffect. The current code already handles this correctly — preserve the structure exactly.

    CRITICAL: `animate={false}` (not `animate={{}}`) — when false, framer-motion stops the animation and returns to initial values. This is the correct way to halt a looping animation. Using `animate={{}}` keeps the current position frozen, not reset.

    The ref must be on the outermost wrapper div (the one with `absolute inset-0`) so IntersectionObserver measures the container's bounding rect against the viewport. If attached to an inner element, it may not fire correctly.
  </action>
  <verify>
    Run `npm run dev`. Open the site in browser. Open DevTools console — no hydration errors should appear.
    Scroll down past the hero section. Observe that FloatingParticles (visible in hero section background) stop animating once the hero is scrolled off-screen (particles freeze in place or disappear). Scroll back up — particles resume floating.
  </verify>
  <done>
    FloatingParticles.tsx imports useInView and useRef. containerRef is attached to the outer div. Particle animate prop is gated on isInView. No hydration errors. Animations pause when off-screen and resume when in view.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add useInView pause to GradientOrb.tsx</name>
  <files>components/GradientOrb.tsx</files>
  <action>
    The current GradientOrb.tsx uses a `motion.div` with a continuous scale+opacity loop. Add useInView to pause it when off-screen.

    Changes required:
    1. Add `useRef` to the React import
    2. Add `useInView` to the framer-motion import (alongside existing `motion`)
    3. Create `const ref = useRef<HTMLDivElement>(null)`
    4. Call `const isInView = useInView(ref)`
    5. Add `ref={ref}` to the existing `<motion.div>` element — this is the correct element since it's the only element in the component and has concrete dimensions
    6. Gate the `animate` prop:
       - When `isInView === true`: `animate={{ scale: [1, 1.2, 1], opacity: [0.2, 0.3, 0.2] }}`
       - When `isInView === false`: `animate={false}`

    The `transition` prop can remain static (it only takes effect when animate is active):
    ```
    transition={{ duration: 8, repeat: Infinity, ease: "easeInOut" }}
    ```

    Note: GradientOrb is used in three places in page.tsx (hero section, contact section). Each instance gets its own ref and independent isInView tracking — this is correct behavior since they are separate component instances.

    NOTE on `animate={false}` behavior: When animate is false, framer-motion stops the animation. The element returns to its `initial` prop values. GradientOrb has no `initial` prop, so it returns to the element's natural CSS state (opacity: 0.20 from the className `opacity-20`). This is acceptable — the orb will appear static when paused.
  </action>
  <verify>
    Run `npm run dev`. The contact section GradientOrb (pink, at the bottom of the page) should be invisible/static when viewing the hero at the top of the page. Scroll to the contact section — the orb should begin pulsing. Scroll back to hero — the hero orbs resume, the contact orb pauses.
  </verify>
  <done>
    GradientOrb.tsx imports useInView and useRef. ref is attached to the motion.div. animate prop is gated on isInView. All three GradientOrb instances on the page pause independently when scrolled off-screen.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes with no errors
- No hydration errors in browser console
- FloatingParticles animations pause when hero is scrolled off-screen
- GradientOrb animations pause when their respective sections are off-screen
</verification>

<success_criteria>
Both animation components gate their looping animations via useInView. Math.random() remains safely inside useEffect. Build passes.
</success_criteria>

<output>
After completion, create `.planning/phases/01-aesthetic-foundation/01-02-SUMMARY.md`
</output>
